# Authoring Simulations Controlled by Blockly

The blockly and agent simulation interactives can be used together to create simulations that students can control using blockly programs.

# Connecting the Interactives

1. Add a blockly and an agent simulation interactive to a page in the Activity Player.
2. Make sure to give your blockly interactive a name (edit it, enter a name, then save your change).
3. Edit the agent simulation interactive.
4. Scroll down to Data Source Interactive and select your blockly interactive.
5. Save your change to the agent simulation interactive.

The agent simulation interactive is now connected to the blockly interactive, and will accept code from it to control its simulation. You must view the page in student view for the connection to work (Preview in: Activity Player at the top right of the Edit Page page).

# Atomic Agents

Agent simulation interactives use the Atomic Agents simulation engine. It has [extensive documentation and examples](https://gjmcn.github.io/atomic-agents/). It uses [Atomic Agents Vis](https://gjmcn.github.io/atomic-agents-vis/) to render the simulation.

This documentation will reference concepts from Atomic Agents and Atomic Agents Vis.

# Setting Up the Simulation

When an agent simulation interactive accepts code from a blockly interactive, it will ignore any of its own code and will only use code provided by the blockly interactive.

After an agent simulation interactive has accepted code from a blockly interactive, a "Show Blockly Code" button will appear under the simulation. Pressing this button will display the code that was transfered between the interactives. This can be very helpful when debugging while authoring a simulation.

## Examples

Files in the `src/sims` directory include examples of simulations that can be helpful when writing simulations.

## Coding the Simulation

Simulation code must be vanilla javascript. All simulation code has access to the following variables:
- `sim` - The Atomic Agents simulation
- `AA` - Everything you'd get from `import * as AA from "atomic-agents"`
- `AV` - Everything you'd get from `import * as AV from "atomic-agents-vis"`
- `globals` - An object that allows you to directly create, access, and modify globals.
  - `globals.createGlobal(globalKey: string, global: { displayName: string, value: any })`
    Allows you to directly create a new global. If the global already exists, this does nothing.
  - `globals.setValue(globalKey: string, value: any)`
    Update the value of the given global.
  - `globals.getValue(globalKey)`
    Returns the current value of the given global.
  - `globals.getDisplayName(globalKey)`
    Returns the displayName for the given global.
- `addWidget` - A function that allows you to add widgets to the simulation.
  - `addWidget` takes a single parameter, an object containing the following:
    - `type` - The type of the widget (see below).
    - `globalKey` - The global this widget is tied to.
    - `defaultValue` - The value to use to intialize the global if it is not already initialized.
    - `data` - An object containing additional information, which is different for different widgets.

### Widgets

#### `readout`

This widget displays the value of the given global.

Unlike most widgets, this one will not create the global if it does not already exist, so you need to create it directly or with another widget before creating this widget.

`data`:
- `backgroundColor: string` - Optional. The color for the widget background.
- `color: string` - Optional. The color for the widget text.
- `label: string` - Optional. Displayed after the global value if included.

#### `slider`

This widget allows the user to change the value of the given global using a horizontal slider.

The global value must be a number. Make sure to include `defaultValue` if the global is not previously defined.

`data`:
- `min: number` - The minimum value for the slider.
- `max: number` - The maximum value for the slider.
- `label: string` - Optional. Displayed before the slider if included.

Blockly code is added in two places: the simulation code, and then within individual block definitions.

## Simulation Code

The simulation code has its own text area when editing a blockly interactive. All of the code included here will be sent as-is to the agent simulation interactive.

## Blockly Code

The blockly program created by a student will generate code. This code will be included alongside the simulation code and passed together to the agent simulation interactive.

Different blocks generate code in different ways. Some automatically produce code, and using these blocks will require you to set up your simulation code in specific ways. Other blocks require authors to provide their own code.

### Starter Blocks

#### Setup

This block defines the `setup` function, which will include the code generated by all blocks contained in the setup block. In order for this block to do anything, include `setup();` at the bottom of the simulation code.

#### Go

This block defines the `sim.afterTick` method. If you define your own `sim.afterTick` method in the simulation code, the method defined by this block will override it.

#### On Mouse Click

This block currently defines a function called `onClick`, which can be used as an event listener (see [Atomic Agents Vis Interaction](https://gjmcn.github.io/atomic-agents-vis/#/?id=interaction)).

### Creator Blocks

These custom blocks are used to create actors of different types in the simulation. They generate code like:

`create_[type]([count], [callback]);`

- `type` is the Object Name specified in the edit block UI
- `count` is a value specified by a user
- `callback` is a function like `(agent) => { [statements] }`
  - `agent` is the newly created agent (the callback should be called with every agent created)
  - `statements` is the code generated by blocks contained within the creator block (usually setters)
  - If the creator block contains no blocks, the callback will NOT be included

To use a creator block, the author needs to define a function called `create_[type]` for each type the creator block allows.
- The function should take a `count` and a `callback` (which might be `undefined`).
- It should create `count` actors.
- Each actor should have a label `type` applied to it.
  - Note that the label should be exactly the same as the `type`--be mindful of singular vs plural here.
- If provided, `callback` should be called on each new actor.

#### Example

This example is from `predator-prey`. The first function, `create_a_wolf`, creates a single new actor. Note that "wolves" is applied as a label. This function is called by `create_wolves`, which is what is directly called by the code generated by the creator block. This function calls `ceate_a_wolf` `count` times, calling `callback` on each newly created agent (assuming `callback` is actually defined).

```
function create_a_wolf(props) {
  const { color, energy, x, y } = props ?? {};
  const agent = new AA.Actor();
  agent.radius = 10;
  agent.vel = AA.Vector.randomAngle(1.5);
  agent.vis({ image: wolfImage, tint: color ?? "0x333333" });
  agent.label("wolves", true);
  agent.state = { energy: energy ?? wolfEnergy };
  agent.x = x ?? Math.random() * sim.width;
  agent.y = y ?? Math.random() * sim.height;

  agent.addTo(sim);
  return agent;
};

function create_wolves(num, callback) {
  for (let i = 0; i < num; i++) {
    const agent = create_a_wolf();
    if (callback) callback(agent);
  }
}
```

### Set Properties Blocks

These custom blocks are used to generate setters. These blocks generate code like:

`set_[property](agent, "[value]");`

- `property` is the Property Name specified in the edit block UI
- `value` is the value specified in the block (either a string from a dropdown menu or a number)
  - Note that `value` is always wrapped in quotes, even if it is a number.

To use a setter block, the author needs to define a function called `set_[property]`.
- It should take an agent as the first argument.
  - The agent will be provided if the block is used within a creator or ask block. In other contexts, the author will have to ensure an agent is defined, or the student will see an error.
- It should take a value as the second argument.

What the function does is up to the author, but a common pattern is:

```
function set_size(agent, value) {
  agent.state.size = value;
}
```

### Ask Blocks

These custom blocks are used to loop through all agents of a particular type and execute code for each one.
- When creating an ask block, the author will have to specify a Target Entity. These are based on creator blocks that have been previously defined.
- The creator block will contain a dropdown with each `type` specified for the chosen Target Entity, as well as "all".

The block will generate different code depending on whether a `type` or "all" is specified. For "all":

`sim.actors.forEach(actor => { [statements] });`

For a `type`:

`sim.withLabel("[type]").forEach(actor => { [statements] });`

- `statements` is the code generated by blocks contained within the ask block.

An author doesn't have to do anything special for an ask block to work.

### Action Blocks

Custom action blocks give authors a lot of flexibility to create blocks that can do a wide range of things that a simulation might need. Many different types of fields can be added to action blocks. And action blocks require custom code to be specified by an author.

Check example simulations for ideas on how to use action blocks.

### Condition Blocks

Custom condition blocks allow authors to create conditions that can be used within if, when, or many other types of blocks. Like action blocks, they require authors to write their own custom code to generate.
