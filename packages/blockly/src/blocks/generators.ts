import { BlockSvg } from "blockly";
import { javascriptGenerator, Order } from "blockly/javascript";
import { ICustomBlock, IParameter, IBlockConfig } from "../components/types";
import { replaceParameters } from "../utils/block-utils";

// Handle collapsed blocks -- statements input may not exist.
function getStatementsCode(block: BlockSvg): string {
  if (block.getInput("statements")) {
    return javascriptGenerator.statementToCode(block, "statements");
  } else {
    // Block is collapsed -- use cached code.
    return (block as any).__cachedChildrenCode || "";
  }
}

export const createGenerator = (blockDef: ICustomBlock, blockConfig: IBlockConfig) => {
  return function(block: BlockSvg): string | [string, Order] {
    switch (blockDef.type) {
      case "action": {
        // If a generatorTemplate is provided, interpolate parameter fields
        const actionName = blockDef.name.toLowerCase().replace(/\s+/g, "_");

        if (blockConfig.generatorTemplate) {
          let code = String(blockConfig.generatorTemplate);
          code = replaceParameters(code, blockConfig.parameters || [], block);
          // Allow ${STATEMENTS} or ${CHILDBLOCKS} for the code generated by child blocks
          const statements = getStatementsCode(block);
          code = code.replace(/\$\{STATEMENTS\}/g, statements);
          code = code.replace(/\$\{CHILDBLOCKS\}/g, statements);
          // Also allow ${ACTION} for the action name
          code = code.replace(/\$\{ACTION\}/g, actionName);
          return code.endsWith("\n") ? code : code + "\n";
        }

        // Fallback: build from parameters
        const parts: string[] = [actionName];
        if (Array.isArray(blockConfig.parameters) && blockConfig.parameters.length > 0) {
          blockConfig.parameters.forEach((param: IParameter) => {
            if (param.labelText && (param.labelPosition ?? "prefix") === "prefix") {
              parts.push(String(param.labelText));
            }
            const v = block.getFieldValue(param.name);
            if (v) parts.push(String(v));
            if (param.labelText && (param.labelPosition ?? "prefix") === "suffix") {
              parts.push(String(param.labelText));
            }
          });
        }

        return parts.join(" ") + "\n";
      }

      case "setter": {
        // This is probably at least close to what we want.
        const attributeName = blockDef.name.toLowerCase().replace(/\s+/g, "_");
        const value = block.getFieldValue("value");

        return `set_${attributeName}(agent, "${value}");\n`;
      }

      case "creator": {
        // This is probably NOT close to what we want. There can be other parameters
        // to take into consideration and statements to process, e.g. child setter blocks.
        // For now, though, we just return a simple create command. 
        const count = block.getFieldValue("count");
        const type = (block.getFieldValue("type") || "").toLowerCase().replace(/\s+/g, "_");

        const statements = getStatementsCode(block);
        const callback = statements ? `(agent) => {\n${statements}\n}` : "";

        return `create_${type}(${count}, ${callback});\n`;
      }

      case "ask": {
        const target = block.getFieldValue("target");
        const agents = target === "all" ? "sim.actors" : `sim.withLabel("${target}")`;

        const statements = getStatementsCode(block);

        return `${agents}.forEach(agent => {\n${statements}\n});\n`;
      }

      case "condition": {
        const condition = block.getFieldValue("condition");
        if (blockConfig.generatorTemplate) {
          let code = replaceParameters(blockConfig.generatorTemplate, blockConfig.parameters || [], block);
          code = code.replace(/\$\{CONDITION\}/g, condition);
          return [code, Order.ATOMIC];
        }
  
        return condition;
      }

      case "globalValue": {
        const globalName = blockConfig.globalName || blockDef.name;
        return [`globals.get("${globalName}")`, Order.ATOMIC];
      }

      default:
        return "";
    }
  };
};
